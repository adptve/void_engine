/// @file font.cpp
/// @brief Bitmap font implementation with built-in font data

#include <void_engine/ui/font.hpp>

#include <algorithm>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <mutex>

namespace void_ui {

// =============================================================================
// Built-in 8x16 Font Data
// =============================================================================

// Complete 8x16 bitmap font for ASCII 32-127 (96 glyphs)
// Each glyph is 16 bytes, one byte per row, bits are pixels from MSB to LSB
// This is a classic VGA-style bitmap font

static const std::array<std::array<std::uint8_t, 16>, 96> BUILTIN_FONT_DATA = {{
    // 0x20 ' ' (space)
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x21 '!'
    {{0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18,
      0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00}},
    // 0x22 '"'
    {{0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x23 '#'
    {{0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C,
      0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00}},
    // 0x24 '$'
    {{0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06,
      0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00}},
    // 0x25 '%'
    {{0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18,
      0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00}},
    // 0x26 '&'
    {{0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC,
      0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00}},
    // 0x27 '''
    {{0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x28 '('
    {{0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30,
      0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00}},
    // 0x29 ')'
    {{0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C,
      0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00}},
    // 0x2A '*'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF,
      0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x2B '+'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E,
      0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x2C ','
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00}},
    // 0x2D '-'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x2E '.'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00}},
    // 0x2F '/'
    {{0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18,
      0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00}},
    // 0x30 '0'
    {{0x00, 0x00, 0x3C, 0x66, 0xC3, 0xC3, 0xDB, 0xDB,
      0xC3, 0xC3, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00}},
    // 0x31 '1'
    {{0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18,
      0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00}},
    // 0x32 '2'
    {{0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30,
      0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00}},
    // 0x33 '3'
    {{0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06,
      0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x34 '4'
    {{0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE,
      0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00}},
    // 0x35 '5'
    {{0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06,
      0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x36 '6'
    {{0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6,
      0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x37 '7'
    {{0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18,
      0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00}},
    // 0x38 '8'
    {{0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6,
      0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x39 '9'
    {{0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06,
      0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00}},
    // 0x3A ':'
    {{0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
      0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x3B ';'
    {{0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
      0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00}},
    // 0x3C '<'
    {{0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60,
      0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00}},
    // 0x3D '='
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00,
      0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x3E '>'
    {{0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06,
      0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00}},
    // 0x3F '?'
    {{0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18,
      0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00}},
    // 0x40 '@'
    {{0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE,
      0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x41 'A'
    {{0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE,
      0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00}},
    // 0x42 'B'
    {{0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66,
      0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00}},
    // 0x43 'C'
    {{0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0,
      0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00}},
    // 0x44 'D'
    {{0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66,
      0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00}},
    // 0x45 'E'
    {{0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
      0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00}},
    // 0x46 'F'
    {{0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
      0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00}},
    // 0x47 'G'
    {{0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE,
      0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00}},
    // 0x48 'H'
    {{0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6,
      0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00}},
    // 0x49 'I'
    {{0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18,
      0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00}},
    // 0x4A 'J'
    {{0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
      0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00}},
    // 0x4B 'K'
    {{0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78,
      0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00}},
    // 0x4C 'L'
    {{0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60,
      0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00}},
    // 0x4D 'M'
    {{0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6,
      0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00}},
    // 0x4E 'N'
    {{0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE,
      0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00}},
    // 0x4F 'O'
    {{0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
      0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x50 'P'
    {{0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60,
      0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00}},
    // 0x51 'Q'
    {{0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
      0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00}},
    // 0x52 'R'
    {{0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C,
      0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00}},
    // 0x53 'S'
    {{0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C,
      0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x54 'T'
    {{0x00, 0x00, 0xFF, 0xDB, 0x99, 0x18, 0x18, 0x18,
      0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00}},
    // 0x55 'U'
    {{0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
      0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x56 'V'
    {{0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3,
      0xC3, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00}},
    // 0x57 'W'
    {{0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6,
      0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00}},
    // 0x58 'X'
    {{0x00, 0x00, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x18,
      0x3C, 0x66, 0xC3, 0xC3, 0x00, 0x00, 0x00, 0x00}},
    // 0x59 'Y'
    {{0x00, 0x00, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18,
      0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00}},
    // 0x5A 'Z'
    {{0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30,
      0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00}},
    // 0x5B '['
    {{0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30,
      0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00}},
    // 0x5C '\'
    {{0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38,
      0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00}},
    // 0x5D ']'
    {{0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
      0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00}},
    // 0x5E '^'
    {{0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x5F '_'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00}},
    // 0x60 '`'
    {{0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x61 'a'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C,
      0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00}},
    // 0x62 'b'
    {{0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66,
      0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x63 'c'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0,
      0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x64 'd'
    {{0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC,
      0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00}},
    // 0x65 'e'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE,
      0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x66 'f'
    {{0x00, 0x00, 0x1C, 0x36, 0x32, 0x30, 0x78, 0x30,
      0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00}},
    // 0x67 'g'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
      0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00}},
    // 0x68 'h'
    {{0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66,
      0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00}},
    // 0x69 'i'
    {{0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18,
      0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00}},
    // 0x6A 'j'
    {{0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06,
      0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00}},
    // 0x6B 'k'
    {{0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78,
      0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00}},
    // 0x6C 'l'
    {{0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18,
      0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00}},
    // 0x6D 'm'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0xFF, 0xDB,
      0xDB, 0xDB, 0xDB, 0xDB, 0x00, 0x00, 0x00, 0x00}},
    // 0x6E 'n'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
      0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00}},
    // 0x6F 'o'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6,
      0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x70 'p'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
      0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00}},
    // 0x71 'q'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
      0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00}},
    // 0x72 'r'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66,
      0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00}},
    // 0x73 's'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60,
      0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00}},
    // 0x74 't'
    {{0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30,
      0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00}},
    // 0x75 'u'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC,
      0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00}},
    // 0x76 'v'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xC3, 0xC3,
      0xC3, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00}},
    // 0x77 'w'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6,
      0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00}},
    // 0x78 'x'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38,
      0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00}},
    // 0x79 'y'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6,
      0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00}},
    // 0x7A 'z'
    {{0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18,
      0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00}},
    // 0x7B '{'
    {{0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18,
      0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00}},
    // 0x7C '|'
    {{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18,
      0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00}},
    // 0x7D '}'
    {{0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18,
      0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00}},
    // 0x7E '~'
    {{0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
    // 0x7F (DEL - shown as block)
    {{0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6,
      0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00}},
}};

const std::array<std::array<std::uint8_t, 16>, 96>& get_builtin_font_data() {
    return BUILTIN_FONT_DATA;
}

// =============================================================================
// BitmapFont Implementation
// =============================================================================

BitmapFont::BitmapFont() = default;
BitmapFont::~BitmapFont() = default;

BitmapFont::BitmapFont(BitmapFont&&) noexcept = default;
BitmapFont& BitmapFont::operator=(BitmapFont&&) noexcept = default;

BitmapFont BitmapFont::create_builtin() {
    BitmapFont font;
    font.m_name = "builtin";
    font.m_glyph_width = GLYPH_WIDTH;
    font.m_glyph_height = GLYPH_HEIGHT;
    font.m_use_builtin = true;

    // Pre-populate glyph map for faster lookup
    for (char32_t ch = 32; ch < 128; ++ch) {
        Glyph glyph;
        glyph.codepoint = ch;
        glyph.width = GLYPH_WIDTH;
        glyph.height = GLYPH_HEIGHT;
        glyph.advance = static_cast<std::int32_t>(GLYPH_WIDTH);
        glyph.bearing_x = 0;
        glyph.bearing_y = static_cast<std::int32_t>(GLYPH_HEIGHT);

        // Copy bitmap data
        const auto& src = BUILTIN_FONT_DATA[ch - 32];
        glyph.bitmap.assign(src.begin(), src.end());

        font.m_glyphs[ch] = std::move(glyph);
    }

    return font;
}

std::unique_ptr<BitmapFont> BitmapFont::load_from_file(
    const std::string& path,
    std::uint32_t glyph_width,
    std::uint32_t glyph_height,
    std::uint32_t chars_per_row,
    char first_char) {

    // Read file
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        return nullptr;
    }

    auto size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<std::uint8_t> data(static_cast<std::size_t>(size));
    if (!file.read(reinterpret_cast<char*>(data.data()), size)) {
        return nullptr;
    }

    // For now, we only support raw bitmap data (not PNG/BMP)
    // In a full implementation, you would decode the image format here
    // For simplicity, assume 1-bit-per-pixel raw data

    // Calculate expected dimensions
    std::uint32_t num_chars = 96; // ASCII 32-127
    std::uint32_t rows = (num_chars + chars_per_row - 1) / chars_per_row;
    std::uint32_t image_width = chars_per_row * glyph_width;
    std::uint32_t image_height = rows * glyph_height;

    // For 1bpp data: (width * height + 7) / 8 bytes
    std::size_t expected_size = (image_width * image_height + 7) / 8;

    if (data.size() < expected_size) {
        // Not raw bitmap data - would need image decoder
        // Fall back to builtin for now
        auto font = std::make_unique<BitmapFont>(create_builtin());
        font->m_name = std::filesystem::path(path).stem().string();
        return font;
    }

    return load_from_data(data.data(), data.size(),
                          image_width, image_height,
                          glyph_width, glyph_height,
                          chars_per_row, first_char);
}

std::unique_ptr<BitmapFont> BitmapFont::load_from_data(
    const std::uint8_t* data,
    std::size_t data_size,
    std::uint32_t image_width,
    std::uint32_t image_height,
    std::uint32_t glyph_width,
    std::uint32_t glyph_height,
    std::uint32_t chars_per_row,
    char first_char) {

    auto font = std::make_unique<BitmapFont>();
    font->m_name = "custom";
    font->m_glyph_width = glyph_width;
    font->m_glyph_height = glyph_height;
    font->m_use_builtin = false;

    // Assume 8bpp grayscale data for simplicity
    // Threshold at 128 for black/white
    if (data_size < image_width * image_height) {
        return nullptr;
    }

    std::uint32_t num_chars = 96;
    for (std::uint32_t i = 0; i < num_chars; ++i) {
        char32_t ch = static_cast<char32_t>(first_char + i);

        std::uint32_t col = i % chars_per_row;
        std::uint32_t row = i / chars_per_row;

        std::uint32_t start_x = col * glyph_width;
        std::uint32_t start_y = row * glyph_height;

        Glyph glyph;
        glyph.codepoint = ch;
        glyph.width = glyph_width;
        glyph.height = glyph_height;
        glyph.advance = static_cast<std::int32_t>(glyph_width);
        glyph.bearing_x = 0;
        glyph.bearing_y = static_cast<std::int32_t>(glyph_height);

        // Convert to 1bpp bitmap (one byte per row)
        glyph.bitmap.resize(glyph_height);

        for (std::uint32_t y = 0; y < glyph_height; ++y) {
            std::uint8_t row_byte = 0;
            for (std::uint32_t x = 0; x < glyph_width; ++x) {
                std::size_t src_idx = (start_y + y) * image_width + (start_x + x);
                if (src_idx < data_size && data[src_idx] > 128) {
                    row_byte |= (1 << (7 - x));
                }
            }
            glyph.bitmap[y] = row_byte;
        }

        font->m_glyphs[ch] = std::move(glyph);
    }

    return font;
}

const Glyph* BitmapFont::get_glyph(char32_t ch) const {
    auto it = m_glyphs.find(ch);
    if (it != m_glyphs.end()) {
        return &it->second;
    }

    // Return space glyph for unknown characters
    it = m_glyphs.find(U' ');
    if (it != m_glyphs.end()) {
        return &it->second;
    }

    return nullptr;
}

const std::array<std::uint8_t, 16>& BitmapFont::get_builtin_glyph(char ch) {
    if (ch < 32 || ch > 127) {
        return BUILTIN_FONT_DATA[0]; // Space
    }
    return BUILTIN_FONT_DATA[static_cast<std::size_t>(ch - 32)];
}

bool BitmapFont::has_glyph(char32_t ch) const {
    return m_glyphs.find(ch) != m_glyphs.end();
}

float BitmapFont::measure_text(const std::string& text, float scale) const {
    float width = 0.0f;
    float scaled_advance = static_cast<float>(m_glyph_width) * scale;

    for (char ch : text) {
        if (ch == '\t') {
            // Tab = 4 spaces
            width += scaled_advance * 4.0f;
        } else if (ch == '\n') {
            // Newlines don't add to width
        } else {
            width += scaled_advance;
        }
    }

    return width;
}

float BitmapFont::measure_text(const std::u32string& text, float scale) const {
    float width = 0.0f;
    float scaled_advance = static_cast<float>(m_glyph_width) * scale;

    for (char32_t ch : text) {
        if (ch == U'\t') {
            width += scaled_advance * 4.0f;
        } else if (ch == U'\n') {
            // Newlines don't add to width
        } else {
            const Glyph* glyph = get_glyph(ch);
            if (glyph) {
                width += static_cast<float>(glyph->advance) * scale;
            } else {
                width += scaled_advance;
            }
        }
    }

    return width;
}

float BitmapFont::text_height(float scale) const {
    return static_cast<float>(m_glyph_height) * scale;
}

float BitmapFont::line_height(float scale, float line_height_mult) const {
    return static_cast<float>(m_glyph_height) * scale * line_height_mult;
}

// =============================================================================
// FontRegistry Implementation
// =============================================================================

struct FontRegistry::Impl {
    std::unordered_map<std::string, std::unique_ptr<BitmapFont>> fonts;
    std::string active_font_name = "builtin";
    BitmapFont builtin_font;

    // Hot-reload state
    std::string watch_path;
    bool watching = false;
    std::unordered_map<std::string, std::filesystem::file_time_type> file_times;
    FontChangedCallback on_font_changed;

    std::mutex mutex;

    Impl() : builtin_font(BitmapFont::create_builtin()) {}
};

FontRegistry::FontRegistry() : m_impl(std::make_unique<Impl>()) {
    // Register builtin font
    auto builtin = std::make_unique<BitmapFont>(BitmapFont::create_builtin());
    m_impl->fonts["builtin"] = std::move(builtin);
}

FontRegistry::~FontRegistry() {
    stop_watching();
}

void FontRegistry::register_font(const std::string& name, std::unique_ptr<BitmapFont> font) {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    if (font) {
        font->set_name(name);
        m_impl->fonts[name] = std::move(font);
    }
}

void FontRegistry::unregister_font(const std::string& name) {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    if (name != "builtin") {
        m_impl->fonts.erase(name);
        if (m_impl->active_font_name == name) {
            m_impl->active_font_name = "builtin";
        }
    }
}

const BitmapFont* FontRegistry::get_font(const std::string& name) const {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    auto it = m_impl->fonts.find(name);
    if (it != m_impl->fonts.end()) {
        return it->second.get();
    }
    return nullptr;
}

BitmapFont* FontRegistry::get_font_mut(const std::string& name) {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    auto it = m_impl->fonts.find(name);
    if (it != m_impl->fonts.end()) {
        return it->second.get();
    }
    return nullptr;
}

std::vector<std::string> FontRegistry::font_names() const {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    std::vector<std::string> names;
    names.reserve(m_impl->fonts.size());
    for (const auto& [name, font] : m_impl->fonts) {
        names.push_back(name);
    }
    return names;
}

bool FontRegistry::has_font(const std::string& name) const {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    return m_impl->fonts.find(name) != m_impl->fonts.end();
}

void FontRegistry::set_active_font(const std::string& name) {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    if (m_impl->fonts.find(name) != m_impl->fonts.end()) {
        m_impl->active_font_name = name;
    }
}

const BitmapFont& FontRegistry::active_font() const {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    auto it = m_impl->fonts.find(m_impl->active_font_name);
    if (it != m_impl->fonts.end()) {
        return *it->second;
    }
    return m_impl->builtin_font;
}

const std::string& FontRegistry::active_font_name() const {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    return m_impl->active_font_name;
}

bool FontRegistry::load_font_from_file(
    const std::string& name,
    const std::string& path,
    std::uint32_t glyph_width,
    std::uint32_t glyph_height) {

    auto font = BitmapFont::load_from_file(path, glyph_width, glyph_height);
    if (font) {
        std::lock_guard<std::mutex> lock(m_impl->mutex);

        // Track file time for hot-reload
        try {
            auto ftime = std::filesystem::last_write_time(path);
            m_impl->file_times[path] = ftime;
        } catch (...) {
            // Ignore filesystem errors
        }

        font->set_name(name);
        m_impl->fonts[name] = std::move(font);
        return true;
    }
    return false;
}

void FontRegistry::watch_directory(const std::string& path) {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    m_impl->watch_path = path;
    m_impl->watching = true;

    // Scan directory for existing fonts
    try {
        for (const auto& entry : std::filesystem::directory_iterator(path)) {
            if (entry.is_regular_file()) {
                const auto& filepath = entry.path();
                auto ext = filepath.extension().string();

                // Check for supported formats
                if (ext == ".png" || ext == ".bmp" || ext == ".fnt" || ext == ".bin") {
                    auto name = filepath.stem().string();
                    auto ftime = std::filesystem::last_write_time(filepath);
                    m_impl->file_times[filepath.string()] = ftime;
                }
            }
        }
    } catch (const std::filesystem::filesystem_error&) {
        // Directory doesn't exist or not accessible
    }
}

void FontRegistry::stop_watching() {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    m_impl->watching = false;
    m_impl->watch_path.clear();
}

void FontRegistry::poll_changes() {
    std::lock_guard<std::mutex> lock(m_impl->mutex);

    if (!m_impl->watching || m_impl->watch_path.empty()) {
        return;
    }

    try {
        for (const auto& entry : std::filesystem::directory_iterator(m_impl->watch_path)) {
            if (!entry.is_regular_file()) continue;

            const auto& filepath = entry.path();
            auto ext = filepath.extension().string();

            if (ext != ".png" && ext != ".bmp" && ext != ".fnt" && ext != ".bin") {
                continue;
            }

            auto filepath_str = filepath.string();
            auto current_time = std::filesystem::last_write_time(filepath);

            auto it = m_impl->file_times.find(filepath_str);
            if (it == m_impl->file_times.end() || it->second != current_time) {
                // New or modified file
                m_impl->file_times[filepath_str] = current_time;

                auto name = filepath.stem().string();

                // Reload font (need to release lock temporarily)
                m_impl->mutex.unlock();
                auto font = BitmapFont::load_from_file(filepath_str);
                m_impl->mutex.lock();

                if (font) {
                    font->set_name(name);
                    m_impl->fonts[name] = std::move(font);

                    if (m_impl->on_font_changed) {
                        m_impl->on_font_changed(name);
                    }
                }
            }
        }

        // Check for deleted files
        std::vector<std::string> to_remove;
        for (const auto& [path, time] : m_impl->file_times) {
            if (!std::filesystem::exists(path)) {
                to_remove.push_back(path);
            }
        }

        for (const auto& path : to_remove) {
            m_impl->file_times.erase(path);
            auto name = std::filesystem::path(path).stem().string();
            m_impl->fonts.erase(name);

            if (m_impl->active_font_name == name) {
                m_impl->active_font_name = "builtin";
            }

            if (m_impl->on_font_changed) {
                m_impl->on_font_changed(name);
            }
        }

    } catch (const std::filesystem::filesystem_error&) {
        // Directory access error, will retry next poll
    }
}

void FontRegistry::set_font_changed_callback(FontChangedCallback callback) {
    std::lock_guard<std::mutex> lock(m_impl->mutex);
    m_impl->on_font_changed = std::move(callback);
}

} // namespace void_ui
